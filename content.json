[{"title":"ES6入门之let、const、作用域","date":"2017-01-06T10:51:25.199Z","path":"2017/01/06/ES6入门之let、const、作用域/","text":"let命令 基本用法es6新增了let命令来声明变量，但它声明的变量只在let命令所在的代码所在的代码块内有效。 { let a=10; var b=10; } console.log(a); //报错 a is not defined console.log(b); //10 根据这个特性，let命令就很适合for循环 for(let i=0;i&lt;10;i++){} console.log(i); //报错 i只在for体内有效，在循环体外应用会报错 注意比较下面的代码的区别 for(var i=0;i&lt;10;i++){ a[i]=function(){ console.log(i); } } a[5](); //输出10 for(let i=0;i&lt;10;i++){ a[i]=function(){ console.log(i); } } a[5](); //输出5 上面的代码，用var声明的i是全局的，每一次循环i的值都会刷新，所以输出的是最新的10； 如果使用的是let，声明的变量仅在块级作用域中有效，最后输出5。 注意：每一次循环的i都是一个新的变量（重新声明），也可以理解为这个循环产生了10个作用域。 特点不存在变量提升let不存在变量名提升。变量一定要在声明后使用，否则会报错。 console.log(a);//输出undefined var a=1; //var存在变提升 console.log(b); //报错 let b=1; //let不存在变量提升 注意：let，const虽然不会提升变量名，但是会形成封闭作用域。在声明之前使用这些变量就会报错。哪怕全局存在这个变量。实例如下： var a=1; if(true){ a=2; //报错 let a; } 这个语法上称为”暂时性死区”。同样的，typeof也不像之前一样绝对安全。现在在let声明之前使用typeof（声明的变量）会报错。要是没有let声明会返回undefined。 不允许重复声明let不允许在相同的作用域内，重复声明一个变量。 { let a=1; var a=1; //报错 } { let a=1; let a=1; //报错 } function fn（a）{ let a; //报错 } function fn（a）{ { let a; //不报错 } } 注意函数形参的自动声明。不能在函数内部重新声明参数。 块级作用域es5只有全局作用域和函数作用域，并没有块级作用域。这会造成内层变量将外层覆盖，for循环变量泄露成全局变量（循环结束不消失）。 let给es6带来了块级作用域。 1.外层代码不受内层代码的影响。 let a=1; { let a=2; } console.log(a); //输出1； 2.块级作用可以任意嵌套 但是外层作用域无法读取内层作用域的变量。 {{{{ { let a=1; } console.log(a); //报错 }}}} 3.块级作用域使得自调用函数不在必要了。 （function(){var a=1;}）(); 可以替换为 { let a=1； } 4.块级作用域内声明函数，其行为类似let，在块级作用域外不能应用该函数。 实际上这个规定存在很大的兼容性问题，应该避免在块级作用域内声明函数。如果确实需要，应该写成函数表达式，而不是函数声明。 { let fn=function(){} } if(true) function(){} //会报错 必须要大括号 const命令const声明一个常量。一旦声明，常量的值就不会改变。 1.const声明的时候的必须初始化其值。 const a=1； const b; //报错 2.const的作用域同let:只在其所在的块级作用域内生效 3.const命令声明的常量也不提升，只能在声明后使用。同let 4.const声明不能重复声明。同let 5. 对于复合型变量，变量名指向数据的地址。const只能保证指向地址不变，但不能保证地址所在的数据不变。 const a={}; a.abc=123; //可执行 a=[]; //报错 如果想将一个对象冻结，不让其改变可以用object.freeze方法。 const obj=obiect.freeze({}); foo.a=1; //在严格模式下报错 在常规模式下不起作用 这个方法可以冻结对象本身，但不能冻结对象的属性。下面方法可以彻底冻结： var dongjie =(obj)=&gt;{ object.freeze(obj); object.keys(obj).foreach((v,i)=&gt;{ if(typeof obj[v]===&apos;object&apos;){ dongjie(obj[v])} }); }; 补充：var和function声明的变量是全局变量，是顶层对象的属性。但let和const声明的变量不属于顶层对象的属性。 var a=1; console.log(window.a); //输出1 let b=2; console.log(window.b); //输出undefined","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6入门之babel转码","date":"2017-01-03T11:36:10.556Z","path":"2017/01/03/ES6入门之babel转码器/","text":"es6虽然出现有一段时间，各大浏览器对es6的支持度也越来越高，不过兼容性性依旧是个蛋疼的问题。今天，我就来讲讲如何用es6的方式编写程序，又不要担心环境时候支持。 附：浏览器对es6的支持可以查看 kangax.github.io/es5-compat-table/es6/。 babel转码器babel是一个广泛使用的es6转码器，可以将es6代码转为es5代码。本文将介绍如何使用babel。 全局编译在npm下安装好babel npm install --global babel-cli &nbsp;&nbsp;安装完成后就可以编译文件 babel a.js -out-file b.js&nbsp;&nbsp;或者babel a.js -o b.js &nbsp;&nbsp;就可以将a.js文件编译到b.js中 &nbsp;&nbsp;也可以将整个目录全部编译： babel src --out-dir lib或者babel src -d lib 但是这种方法并不推荐，一方面对环境产生了，另一方面，无法做到不同的项目使用不同的版本的babel。推荐下面一种方法。 在项目内编译 初始化项目 npm init 安装babel-cli npm install --save-dev babel-cli 修改项目中package.json （在devDependencies上加上script） &quot;scripts&quot;: { &quot;build&quot;: &quot;babel src -d lib&quot; }, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.10.1&quot; } 在项目的根目录下创建 .babelrc 文件（window系统可以用webstrom等软件创建）,在文件内输入以下内容： { &quot;presets&quot;: [], &quot;plugins&quot;: [] } 为了让babel将es6转化为es5，还需要安装： npm install --save-dev babel-preset-es2015 安装完成后在.babelrc中添加参数： { &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [] } 大功告成！下面来试一试 新建1.js 写上 let a = 1 在终端输入 babel 1.js -o 2.js 在项目中出现2.js文件 并出现如下代码 &quot;use strict&quot; var a=1; 编译成功，下面来试试整个目录编译： 新建src文件 在里面写几个js文件 然后在终端运行 npm run build 执行后在终端会显示 &gt; learn-es6@1.0.0 build c:\\gitWorkSpace\\learn-es6 &gt; babel src -d lib 然后就可以在项目中看到lib文件，里面存放的都是编译完成后的js文件。 很好，环境已经说完，下面开始正式进入es6的学习！","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]