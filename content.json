[{"title":"ES6入门之数值、数组、字符串的扩展","date":"2017-01-17T06:30:51.262Z","path":"2017/01/17/ES6入门之数值、数组、字符串的扩展/","text":"数值的扩展1.二进制和八进制表示法es6提供了二进制和八进制数值的新写法，分别用前缀0b（0B）和0o（0O）表示。 0b111110111===503 //true 0o767===503 //true 可以用Number将0b和0o前缀的字符串数值转为十进制。 Number（&apos;0b111&apos;） //7 Number(&apos;0o10&apos;) //8 2.Number.isFinite(),Number.isNaN()Number.isFinite()用来检查一个数值时候为有限的，返回布尔值。 Number.isFinite(100); //true Number.isFinite(0.002); //true Number.isFinite(NaN); //false Number.isFinite(Infinity) //false Number.isFinite(&apos;100&apos;) //false Number.isFinite(true); //false Number.isNaN()用来检查一个值是否为NaN。 注：这两个方法只对数值有效，非数值返回false。 3.Number.parseInt(),Number.parseFloat()es6将全局方法parseInt（）和parseFloat()移植到Number对象上。功能保持不变。 4.Number.isInteger() 判断一个数是否是整数。注意：js中整数和浮点数的存储方式相同 3和3.0是同一个值。 Number.isInteger(3) //true Number.isInteger(3.0) //true Number.isInteger(3.1) //true 5.NUmber.EPSILON 这是一个极小的常量 如果浮点数的计算误差小于这个值 即视为得到了正确的结果。6.安全整数和Number.isSafeInteger()。es6引入Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量表示安全整数的范围。Number.isSafeInteger()用来判断一个整数是否在这个范围之内。 7.Math对象的扩展1.Math.trunc() //去除一个数的小数部分，返回整数部分 Math.trunc(4.1) //4 Math.trunc(-4.1) //-4 Math.trunc(&apos;123.456&apos;) //123 会先把string转换为number Math.trunc(&apos;abc&apos;) //nan 无法截取整数的值返回NAN 2.Math.sign() 判断一个数是正数，负数，还是零 参数是正数 返回+1； 参数是负数 返回-1； 参数是0，返回0； 参数是-0，返回-0； 其他值，返回NaN 3.Math.cbrt() 用于计算一个数的立方根 4.Math.clz32() 返回一个数的32位无符号整数形式前面有多少个0。对于小数只考虑整数部分 5.Math.imul() 返回两个数以32位形式相乘的结果 6.Math.fround() 返回最接近小数的单精度浮点数，对于整数返回原值。 7.Math.hypot() 返回所有参数的平方和的平方根 Math.hypot(3,4) //5 8.对数方法1.Math.expm1() //返回e的x次方再减1的值 2.Math.log1p() //返回Math.log（x+1)的值 3.Math.log10() //返回以10为底x的对数 4.Math.log2() //返回以2为底x的对数 9.三角函数方法Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 10.指数运算符（**）2**2 //4 2**3 //8 let a=2; a **=3; //等同于a=a**3 a=a*a*a 数组的扩展1.Array.from() 可以将类似数组的对象和可遍历的对象转化为真正的数组。let obj={&apos;0&apos;:&quot;a&quot;,&quot;1&quot;:&quot;b&quot;,&quot;2&quot;:&quot;c&quot;,length:3} let arr=Array.from(obj) //[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 常用于dom操作返回的nodelist集合以及函数内部的arguments对象。类似数组的本质就是拥有length属性。 Array.from({length:3}) //[undefined.undefined,undefined]Array.from() 可以接受两个参数 第二个参数接受一个方法对每个元素进行处理，将处理好的值返回数组（类似map方法） Array.from([1,2,3] , (x) =&gt;x*x) //[1,4,9] 2.Array.of() 用于将一组值转化为数组Array.of(3,11,8) //[3,11,8]。 参数为空则返回一个空数组。Array.of() 是array（）的完善，注意区别。 3.数组实例copyWithin（） 添加在数组原型属性上的方法，可以将指定位置的值复制到其他位置，返回新数组Array.prototype.copyWithin(target,start,end)接受三个参数 target（必须）：从该位置开始替换数据 start（可选）默认为0 表示从该位置开始读取数据 end（可选）默认是数组长度，到该位置停止读取数据。 [1,2,3,4,5].copyWithin(0,3,4) //将第0项的值改为第3项的值 [4,2,3,4,5] [1,2,3,4,5].copyWithin(0,3) //将第3项到结束复制到0号位 [4，5，3,4,5] 4.数组实例的find（）和findIndex（）find方法用于找出第一个符合条件的数组成员，他的参数是一个回调函数。找不到返回undefined [1,4,-10,4].find((n) =&gt;n&lt;0) //-10回调函数可以接受3个参数。依次是当前的值，当前的位置，和原数组 findIndex方法和find类似，他返回第一个符合条件的成员的位置，找不到返回-1 5.数组实例的fill（） 接受定值，填充数组，将已有元素全部抹去。用于初始化数组[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7) //[7,7,7] [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].fill(7，1，2) //[&apos;a&apos;,7,&apos;b&apos;] 第二个参数起始位置 第3个参数结束位置 6.数组实例的entries(),keys(),values() 返回遍历器对象。7.数组实例的includes() f返回一个布尔值 判断数组中是否含有给定的值。8.数组的空位 es5方法会选择跳过空位 es6则不会跳过字符串的扩展","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6入门之let、const、作用域","date":"2017-01-06T10:51:25.199Z","path":"2017/01/06/ES6入门之let、const、作用域/","text":"let命令 基本用法es6新增了let命令来声明变量，但它声明的变量只在let命令所在的代码所在的代码块内有效。 { let a=10; var b=10; } console.log(a); //报错 a is not defined console.log(b); //10 根据这个特性，let命令就很适合for循环 for(let i=0;i&lt;10;i++){} console.log(i); //报错 i只在for体内有效，在循环体外应用会报错 注意比较下面的代码的区别 for(var i=0;i&lt;10;i++){ a[i]=function(){ console.log(i); } } a[5](); //输出10 for(let i=0;i&lt;10;i++){ a[i]=function(){ console.log(i); } } a[5](); //输出5 上面的代码，用var声明的i是全局的，每一次循环i的值都会刷新，所以输出的是最新的10； 如果使用的是let，声明的变量仅在块级作用域中有效，最后输出5。 注意：每一次循环的i都是一个新的变量（重新声明），也可以理解为这个循环产生了10个作用域。 特点不存在变量提升let不存在变量名提升。变量一定要在声明后使用，否则会报错。 console.log(a);//输出undefined var a=1; //var存在变提升 console.log(b); //报错 let b=1; //let不存在变量提升 注意：let，const虽然不会提升变量名，但是会形成封闭作用域。在声明之前使用这些变量就会报错。哪怕全局存在这个变量。实例如下： var a=1; if(true){ a=2; //报错 let a; } 这个语法上称为”暂时性死区”。同样的，typeof也不像之前一样绝对安全。现在在let声明之前使用typeof（声明的变量）会报错。要是没有let声明会返回undefined。 不允许重复声明let不允许在相同的作用域内，重复声明一个变量。 { let a=1; var a=1; //报错 } { let a=1; let a=1; //报错 } function fn（a）{ let a; //报错 } function fn（a）{ { let a; //不报错 } } 注意函数形参的自动声明。不能在函数内部重新声明参数。 块级作用域es5只有全局作用域和函数作用域，并没有块级作用域。这会造成内层变量将外层覆盖，for循环变量泄露成全局变量（循环结束不消失）。 let给es6带来了块级作用域。 1.外层代码不受内层代码的影响。 let a=1; { let a=2; } console.log(a); //输出1； 2.块级作用可以任意嵌套 但是外层作用域无法读取内层作用域的变量。 {{{{ { let a=1; } console.log(a); //报错 }}}} 3.块级作用域使得自调用函数不在必要了。 （function(){var a=1;}）(); 可以替换为 { let a=1； } 4.块级作用域内声明函数，其行为类似let，在块级作用域外不能应用该函数。 实际上这个规定存在很大的兼容性问题，应该避免在块级作用域内声明函数。如果确实需要，应该写成函数表达式，而不是函数声明。 { let fn=function(){} } if(true) function(){} //会报错 必须要大括号 const命令const声明一个常量。一旦声明，常量的值就不会改变。 1.const声明的时候的必须初始化其值。 const a=1； const b; //报错 2.const的作用域同let:只在其所在的块级作用域内生效 3.const命令声明的常量也不提升，只能在声明后使用。同let 4.const声明不能重复声明。同let 5. 对于复合型变量，变量名指向数据的地址。const只能保证指向地址不变，但不能保证地址所在的数据不变。 const a={}; a.abc=123; //可执行 a=[]; //报错 如果想将一个对象冻结，不让其改变可以用object.freeze方法。 const obj=obiect.freeze({}); foo.a=1; //在严格模式下报错 在常规模式下不起作用 这个方法可以冻结对象本身，但不能冻结对象的属性。下面方法可以彻底冻结： var dongjie =(obj)=&gt;{ object.freeze(obj); object.keys(obj).foreach((v,i)=&gt;{ if(typeof obj[v]===&apos;object&apos;){ dongjie(obj[v])} }); }; 补充：var和function声明的变量是全局变量，是顶层对象的属性。但let和const声明的变量不属于顶层对象的属性。 var a=1; console.log(window.a); //输出1 let b=2; console.log(window.b); //输出undefined","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6入门之babel转码","date":"2017-01-03T11:36:10.556Z","path":"2017/01/03/ES6入门之babel转码器/","text":"es6虽然出现有一段时间，各大浏览器对es6的支持度也越来越高，不过兼容性性依旧是个蛋疼的问题。今天，我就来讲讲如何用es6的方式编写程序，又不要担心环境时候支持。 附：浏览器对es6的支持可以查看 kangax.github.io/es5-compat-table/es6/。 babel转码器babel是一个广泛使用的es6转码器，可以将es6代码转为es5代码。本文将介绍如何使用babel。 全局编译在npm下安装好babel npm install --global babel-cli &nbsp;&nbsp;安装完成后就可以编译文件 babel a.js -out-file b.js&nbsp;&nbsp;或者babel a.js -o b.js &nbsp;&nbsp;就可以将a.js文件编译到b.js中 &nbsp;&nbsp;也可以将整个目录全部编译： babel src --out-dir lib或者babel src -d lib 但是这种方法并不推荐，一方面对环境产生了，另一方面，无法做到不同的项目使用不同的版本的babel。推荐下面一种方法。 在项目内编译 初始化项目 npm init 安装babel-cli npm install --save-dev babel-cli 修改项目中package.json （在devDependencies上加上script） &quot;scripts&quot;: { &quot;build&quot;: &quot;babel src -d lib&quot; }, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.10.1&quot; } 在项目的根目录下创建 .babelrc 文件（window系统可以用webstrom等软件创建）,在文件内输入以下内容： { &quot;presets&quot;: [], &quot;plugins&quot;: [] } 为了让babel将es6转化为es5，还需要安装： npm install --save-dev babel-preset-es2015 安装完成后在.babelrc中添加参数： { &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [] } 大功告成！下面来试一试 新建1.js 写上 let a = 1 在终端输入 babel 1.js -o 2.js 在项目中出现2.js文件 并出现如下代码 &quot;use strict&quot; var a=1; 编译成功，下面来试试整个目录编译： 新建src文件 在里面写几个js文件 然后在终端运行 npm run build 执行后在终端会显示 &gt; learn-es6@1.0.0 build c:\\gitWorkSpace\\learn-es6 &gt; babel src -d lib 然后就可以在项目中看到lib文件，里面存放的都是编译完成后的js文件。 很好，环境已经说完，下面开始正式进入es6的学习！","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]